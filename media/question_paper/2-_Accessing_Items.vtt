WEBVTT

1
00:00:04.000 --> 00:00:08.000
So here we have a list of 4 items. We can use square bracketts

2
00:00:08.000 --> 00:00:12.000
to access individual items in this list. So

3
00:00:12.000 --> 00:00:16.000
let's print letters of zero, this will return the

4
00:00:16.000 --> 00:00:20.000
first item in this list. So when we run this program we get

5
00:00:20.000 --> 00:00:24.000
a. Now similar to strings, if we pass

6
00:00:24.000 --> 00:00:28.000
a negative index here. Like -1. This will return

7
00:00:28.000 --> 00:00:32.000
the first item from the end of the list. So,

8
00:00:32.000 --> 00:00:36.000
when we run this, we get d, using square

9
00:00:36.000 --> 00:00:40.000
brackets we can also modify items in the list, so,

10
00:00:40.000 --> 00:00:44.000
lets change the first letter to a capital A,

11
00:00:44.000 --> 00:00:48.000
and then print the entire list, there you go.

12
00:00:48.000 --> 00:00:52.000
So this is the basic of accessing individual

13
00:00:52.000 --> 00:00:56.000
increments in the list, now earlier in the course, you learned that we can use

14
00:00:56.000 --> 00:01:00.000
two index's to slice a string. We have the exact same thing here.

15
00:01:00.000 --> 00:01:04.000
So, we add square brackets, first

16
00:01:04.000 --> 00:01:08.000
index: second index. And this will return

17
00:01:08.000 --> 00:01:12.000
a new list with the first 3 items in our

18
00:01:12.000 --> 00:01:16.000
original list. So if we print our original list,

19
00:01:16.000 --> 00:01:20.000
we can see that it is not changed,

20
00:01:20.000 --> 00:01:24.000
now just like strings if you don't specify the first argument,

21
00:01:24.000 --> 00:01:28.000
0 will be assumed by default, so as you can see, these two expressions

22
00:01:28.000 --> 00:01:32.000
use the exact same result. Similarly, if you

23
00:01:32.000 --> 00:01:36.000
don't include the end index, by default

24
00:01:36.000 --> 00:01:40.000
the length of the list will be used here. So the length of this. So this expression will return

25
00:01:40.000 --> 00:01:44.000
a new list, with all the items in the original list.

26
00:01:44.000 --> 00:01:48.000
And similarly we can also exclude the start index

27
00:01:48.000 --> 00:01:52.000
here, and with this syntax we can get copy of our original

28
00:01:52.000 --> 00:01:56.000
list. There you go. Now when slicing the string,

29
00:01:56.000 --> 00:02:00.000
we can also pass a step, and this is useful

30
00:02:00.000 --> 00:02:04.000
in situations where you want to return every second or every third

31
00:02:04.000 --> 00:02:08.000
element in the original list. So now let me run this code,

32
00:02:08.000 --> 00:02:12.000
we'll get a and c. So B

33
00:02:12.000 --> 00:02:16.000
will be skipped. Let me show you using a better example.

34
00:02:16.000 --> 00:02:20.000
So, I'm going to delete everything here, create a new list,

35
00:02:20.000 --> 00:02:24.000
numbers, here we're going to use the list functions and

36
00:02:24.000 --> 00:02:28.000
pass range of 20. Let's

37
00:02:28.000 --> 00:02:32.000
print our list. So we get numbers 0

38
00:02:32.000 --> 00:02:36.000
to 19. Okay, now let's see what happens when

39
00:02:36.000 --> 00:02:40.000
we add square brackets here with two colons and

40
00:02:40.000 --> 00:02:44.000
2. This will return every other element in the original

41
00:02:44.000 --> 00:02:48.000
list. Take a look. So we get all the

42
00:02:48.000 --> 00:02:52.000
even numbers. 0, 2, 4, and so on. That's pretty cool, isn't it?

43
00:02:52.000 --> 00:02:56.000
Here is another cool thing you can do here. Let's change the

44
00:02:56.000 --> 00:03:00.000
step to negative 1, as you can see

45
00:03:00.000 --> 00:03:04.000
this will return all the items in the original list, but

46
00:03:04.000 --> 00:03:08.000
in reverse order. So these are some useful things you can do with

47
00:03:08.000 --> 00:03:12.000
lists. Next we'll look at unpacking lists.
